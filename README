= The PISCES Kernel Module =
== Run Pisces ==
* load
modins
cpurm 1
sudo $PISCES_PATH/pisces/linux_usr/mem_reserve 1
sudo $PISCES_PATH/pisces/linux_usr/pisces_load $PISCES_PATH/kitten/vmlwk.bin $PISCES_PATH/kitten/user/pisces_daemon/pisces_daemon "console=pisces" 

* launch
sudo $PISCES_PATH/pisces/linux_usr/pisces_launch /dev/pisces-enclave0

* console output
sudo $PISCES_PATH/pisces/linux_usr/pisces_cons /dev/pisces-enclave0

* controll
sudo $PISCES_PATH/pisces/linux_usr/pisces_ctrl /dev/pisces-enclave0

== design ==
* trampoline
offlined cpu uses trampoline code from linux
we modified the init_code to pointer to our gemini_trampoline, such that
linux jumps to gemini_trampoline right after init the cpu to 64 bit mode.
we then load kernel image, initrd and shared_info into offlined memory.  
A 4M identity mapping page table is setup for the guest kernel. Then we jump
to first instruction of the guest kernel binary, the kernel is position independent
code (PIC), thus can execute on any physical memory given a pre-setup ident mapping

* loader memory map
kernel (2M aligned)
2M gap, because kernel clears __bss section after kernel binary
initrd
shared_info

* gemini console
shared memory based console, the shared memory is organized as a circular queue
We implemented a shared memory based console driver in kitten, which pollutes 
the circular queue. In host OS, we move the produced output to a dedicated buffer
area.

* boot params 
available physical memory map
address/size of kernel, initrd and shared_info
SMP table in the future
